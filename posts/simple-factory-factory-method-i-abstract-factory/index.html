<!DOCTYPE HTML>
<html>
    <head>
    <meta charset="UTF-8">
    <meta name="description" content="Your first blog post here
">
    <meta name="keywords" content="static site generator, simple static site, github pages
">
    <title>DSSSG Blog</title>
    <link rel="shortcut icon" type="image/png" href="../../theme/favicon.png"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500&amp;subset=cyrillic" rel="stylesheet">
    <link href='../../theme/normalize.css' rel='stylesheet' type='text/css'>
    <link href='../../theme/prism.css' rel='stylesheet' type='text/css'>
    <style>
        /* Start of "Micro clearfix" */
        .cf { zoom: 1; }
        .cf:before,
        .cf:after { content: ""; display: table; }
        .cf:after { clear: both; }
        /* End of "Micro clearfix" */
    </style>
    <link href='../../theme/common.css' rel='stylesheet' type='text/css'>

    <style>
        /* Start of Permalink Page styles */
        #header {
            height: auto;
        }
        #header img {
            height: 50px;
            width: 50px;
            margin-top:3px;
        }
        #header > a {
            height:56px;
            width:56px;
        }
        #header > a:hover + span.tooltip{
            display: inline;
        }
        h1 {
            font-weight: 500;
        }
        #post-body {
            max-width: 620px;
            font-weight: 400;
            color: #444;
            margin: 20px auto;
            line-height: 1.5;
        }
        #post-body h1, h2, h3 {
            font-family : Arial, Open Sans, Verdana;
            font-weight: 500;
        }
        #post-body blockquote {
            border-left: 5px #e6e6e6 solid;
            margin: 0;
            padding-left: 15px;
        }
        #post-body img {
            max-width: 100%;
            opacity: 0.9;
        }
        #post-body img:hover {
            opacity: 1;
        }
    	#post-body pre {
    	    max-width: 540px;
            margin: 0 auto;
    	}
        span.tooltip {
            display: none;
            position: absolute;
            width: 90px;
            height: 20px;
            line-height: 20px;
            padding: 4px;
            font-size: 12px;
            text-align: center;
            color: rgb(255, 255, 255);
            background: rgba(51, 51, 51, 0.8);
            border-radius: 4px;
            text-shadow: rgba(0, 0, 0, 0.6) 1px 1px 1px;
            box-shadow: none;
            margin-left: 10px;
            margin-top: 15px;
        }
        span.tooltip:after {
            content: "";
            position: absolute;
            width: 0;
            height: 0;
            border-width: 7px;
            border-style: solid;
            border-color: transparent rgba(51, 51, 51, 0.8) transparent transparent;
            top: 7px;
            left: -14px;
        }
        /* End of Permalink Page styles */
    </style>
    </head>
    <body>
        <div id="header">
            <a href="/"><img alt="Cool Image" src="../../theme/logo.jpg"></a>
            <span class="tooltip">More Posts</span>
            <h1>Simple Factory, Factory Method и Abstract Factory
</h1>
        </div>
        <hr>
        <div id="post-body"><p>Simple Factory, Factory Method и Abstract Factory - это паттерны 
проектирования, то есть решения каких-то конкретных проблем проектирования 
программ.</p>
<blockquote><p>Все рассказы серии:</p>
<ul>
<li><a href="/posts/simple-factory-factory-method-i-abstract-factory">Simple Factory, Factory Method и Abstract Factory</a></li>
<li>Bridge</li>
<li>Decorator</li>
<li>Strategy</li>
</ul>
</blockquote>
<p>И Simple Factory, и Factory Method, и Abstract Factory относятся к порождающим 
паттернам, то есть к паттернам, отвечающим за создание объектов.</p>
<p>Первым мы рассмотрим паттерн Simple Factory, так как он самый простой и поможет
понять нам другие паттерны этой статьи.</p>
<h2>Simple Factory</h2>
<p>Пусть у нас есть игра, в которой есть монстры-вампиры и они могут сражаться с
главным героем. Тогда код нашей игры будет выглядеть как-то так:</p>
<pre><code class="lang-cpp">struct Vampire {
    void fight(){
        std::cout &lt;&lt; &quot;Vampire is fighting&quot; &lt;&lt; std::endl;
    }
};

int main(){
    auto monster = Vampire{};
    monster.fight();

    return 0;
}
</code></pre>
<p>Чем плох этот код?</p>
<ol>
<li>Если мы захотим заменить имя класса <code>Vampire</code> на более подходящее, скажем,
<code>RedVampire</code> то нам придется делать замену имени во всем коде.</li>
<li>Пусть у нас был класс <code>Vampire{}</code>, но мы изменили его конструктор и теперь он
принимает аргументом величину здоровья <code>Vampire{100}</code>, тогда по всему коду
опять придется искать и менять.</li>
</ol>
<p>Чтобы показать, что паттерн <em>Simple Factory</em> решает эти проблемы, добавим в нашу
игру вервольфов, отнаследовав от общего интерфейса монстров.</p>
<pre><code class="lang-cpp">
struct Monster {
    virtual void fight() = 0;
};
struct Vampire : Monster{
    void fight(){
        std::cout &lt;&lt; &quot;Vampire is fighting&quot; &lt;&lt; std::endl;
    }
};
struct Werewolf : Monster{
    void fight(){
        std::cout &lt;&lt; &quot;Werewolf is fighting&quot; &lt;&lt; std::endl;
    }
};
</code></pre>
<p>Итак, о самом паттерне. <strong>Паттерн Simple Factory</strong> определяет класс, в котором
есть метод создающий объекты разного типа в зависимости от аргумента этого
метода.</p>
<pre><code class="lang-cpp">struct MonsterFactory {
    std::unique_ptr&lt;Monster&gt; createMonster(std::string monster_type){
        if (monster_type == &quot;vampire&quot;)
            return std::make_unique&lt;Vampire&gt;();
        else if (monster_type == &quot;werewolf&quot;)
            return std::make_unique&lt;Werewolf&gt;();
        return nullptr;
    }
};

int main(){
    MonsterFactory monster_factory;
    auto monster = monster_factory.createMonster(&quot;werewolf&quot;);
    if (monster != nullptr){
        monster-&gt;fight();
    }

    return 0;
}
</code></pre>
<p>Выше были указаны две проблемы, которые возникают при непосредственном создании
объектов классов. Посмотрим, как они были разрешены при использовании паттерна
Simple Factory:</p>
<ol>
<li>Как можно видеть, если мы изменим имя класса <code>Vampire</code> на более подходящее
<code>RedVampire</code>, то нам нужно будет изменить всего одну строчку в createMonster()</li>
<li>То же самое и с конструктором</li>
<li><em>Как бонус</em> мы получили возможность выбора класса для создания объекта во
время работы программы. Например, мы могли попросить пользователя ввести, какого
монстра создать, или сделать выбор случайным  образом.</li>
</ol>
<h2>Factory Method</h2>
<p>Но у паттерна Simple Factory есть и большой недостаток: он нарушает <a href="https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости">принцип
открытости/закрытости</a>.</p>
<p>Когда мы добавляли поддержку класса Werewolf в программу, то изменяли логику
работы старого кода. На месте нашего игрушечного примера могло бы быть что-то
более сложное - объекты классов бы порождались совсем нетривиально. И что-то
могло бы сломаться. Это и есть нарушение принципа открытости/закрытости.</p>
<p>Нам нужно добавлять функциональность в виде классов, что и предлагает делать
паттерн Factory Method.</p>
<pre><code class="lang-cpp">struct Monster {
    virtual void fight() = 0;
};
struct Vampire : Monster{
    void fight(){
        std::cout &lt;&lt; &quot;Vampire is fighting&quot; &lt;&lt; std::endl;
    }
};
struct Werewolf : Monster{
    void fight(){
        std::cout &lt;&lt; &quot;Werewolf is fighting&quot; &lt;&lt; std::endl;
    }
};

struct MonsterFactory {
    virtual std::unique_ptr&lt;Monster&gt; createMonster() = 0;
};

struct VampireFactory : MonsterFactory {
    virtual std::unique_ptr&lt;Monster&gt; createMonster(){
        return std::make_unique&lt;Vampire&gt;();
    }
};

struct WerewolfFactory : MonsterFactory {
    virtual std::unique_ptr&lt;Monster&gt; createMonster(){
        return std::make_unique&lt;Werewolf&gt;();
    }
};

int main(){
    auto factory = WerewolfFactory{};
    auto monster = factory.createMonster();
    monster-&gt;fight();

    return 0;
}
</code></pre>
<h2>Abstract Factory</h2>
<p>Abstract Factory - это почти фабричный метод. Только здесь классы Factory
имеют несколько методов создания объектов, а не один.</p>
<p>Зачем это может быть нужно? Это может быть нужно, если мы хотим порождать
объекты как-то связанные между собой, <em>объекты одной группы</em>. 
Поэтому порождающие их методы и выносят в одну фабрику.</p>
<p>Для нашего примера с монстрами трудно придумать использование Abstract Factory,
поэтому разберем новый пример.</p>
<p>Пусть у нас есть графическое приложение, которое должно работать и в Windows, и
в MacOS. Эти операционные системы совершенно разные, значит коды отрисовки
кнопок и текстовых полей тоже будут различаться.</p>
<p>Имеем классы кнопок и текстовых полей объявленные как:</p>
<pre><code class="lang-cpp">struct Button {
    virtual void draw() = 0;
};
struct WindowsButton : Button {
    void draw(){
        std::cout &lt;&lt; &quot;Rendering Windows button&quot; &lt;&lt; std::endl;
    }
};
struct MacOSButton : Button {
    void draw(){
        std::cout &lt;&lt; &quot;Rendering MacOS button&quot; &lt;&lt; std::endl;
    }
};

struct TextBox {
    virtual void draw() = 0;
};
struct WindowsTextBox : TextBox {
    void draw(){
        std::cout &lt;&lt; &quot;Rendering Windows textbox&quot; &lt;&lt; std::endl;
    }
};
struct MacOSTextBox : TextBox {
    void draw(){
        std::cout &lt;&lt; &quot;Rendering MacOS textbox&quot; &lt;&lt; std::endl;
    }
};
</code></pre>
<p>Тогда пусть WindowsGUIFactory производит кнопки и текстовые поля для Windows, а
MacOSGUIFactory производит кнопки и текстовые поля для MacOS:</p>
<pre><code class="lang-cpp">struct GUIFactory {
    virtual std::unique_ptr&lt;Button&gt; createButton() = 0;
    virtual std::unique_ptr&lt;TextBox&gt; createTextBox() = 0;
};
struct WindowsGUIFactory : GUIFactory {
    std::unique_ptr&lt;Button&gt; createButton(){
        return std::make_unique&lt;WindowsButton&gt;();
    }
    std::unique_ptr&lt;TextBox&gt; createTextBox(){
        return std::make_unique&lt;WindowsTextBox&gt;();
    }
};
struct MacOSGUIFactory : GUIFactory {
    std::unique_ptr&lt;Button&gt; createButton(){
        return std::make_unique&lt;MacOSButton&gt;();
    }
    std::unique_ptr&lt;TextBox&gt; createTextBox(){
        return std::make_unique&lt;MacOSTextBox&gt;();
    }
};

int main(){
    auto factory = std::make_unique&lt;MacOSGUIFactory&gt;();
    auto button = factory-&gt;createButton();
    auto textbox = factory-&gt;createTextBox();

    button-&gt;draw();
    textbox-&gt;draw();

    return 0;
}
</code></pre>
<p>Получили все те же плюсы паттерна Factory Method, только здесь мы подчеркиваем
связность группы порождаемых объектов.</p>
</div>
        <hr>
        <div id="footer">
            <div id="menu">
                <a href="#">Twitter</a>
                <a href="#">Facebook</a>
                <a href="#">Github</a>
            </div>
        </div>
    <script src="../../theme/prism.js"></script>
    </body>
</html>